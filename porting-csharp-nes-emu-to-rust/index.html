<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, viewport-fit=cover"
    />

    <style>
      :root {
        --accent-color: #05a081;
        --accent-color-light: #82d0c0;
      }
    </style>

    <meta name="theme-color" content="#05a081" />

    
      <link rel="icon" href="https:&#x2F;&#x2F;www.jntrnr.com&#x2F;processed_images&#x2F;444e76059742f47b00.png" />
      <link rel="apple-touch-icon" sizes="48x48" href="https:&#x2F;&#x2F;www.jntrnr.com&#x2F;processed_images&#x2F;444e76059742f47b00.png" />
      <link rel="apple-touch-icon" sizes="72x72" href="https:&#x2F;&#x2F;www.jntrnr.com&#x2F;processed_images&#x2F;6dfeb9b0bd094d5a00.png" />
      <link rel="apple-touch-icon" sizes="96x96" href="https:&#x2F;&#x2F;www.jntrnr.com&#x2F;processed_images&#x2F;3959b3b31b7ae92700.png" />
      <link rel="apple-touch-icon" sizes="144x144" href="https:&#x2F;&#x2F;www.jntrnr.com&#x2F;processed_images&#x2F;e644b27af091684500.png" />
      <link rel="apple-touch-icon" sizes="192x192" href="https:&#x2F;&#x2F;www.jntrnr.com&#x2F;processed_images&#x2F;3344ee474c2d849c00.png" />
      <link rel="apple-touch-icon" sizes="256x256" href="https:&#x2F;&#x2F;www.jntrnr.com&#x2F;processed_images&#x2F;d92103ca49c6bd5e00.png" />
      <link rel="apple-touch-icon" sizes="384x384" href="https:&#x2F;&#x2F;www.jntrnr.com&#x2F;processed_images&#x2F;b8dd2689e662c9cd00.png" />
      <link rel="apple-touch-icon" sizes="512x512" href="https:&#x2F;&#x2F;www.jntrnr.com&#x2F;processed_images&#x2F;c0d9496000275d3400.png" />
    

    

    <meta property="og:type" content="website">

    <meta name="twitter:card" content="summary">

    

    

    
      
        <meta name="description" content="" />
        <meta name="twitter:description" content="">
      
    

    
      <meta name="twitter:title" content="Porting a C# NES emulator to Rust">
    

    
      <link rel="prerender" href="&#x2F;" />
    
      <link rel="prerender" href="&#x2F;tags" />
    
      <link rel="prerender" href="https:&#x2F;&#x2F;www.twitter.com&#x2F;jntrnr" />
    
      <link rel="prerender" href="&#x2F;atom.xml" />
    
      <link rel="prerender" href="&#x2F;poems&#x2F;waitingtogrow" />
    

    <link rel="prefetch" href="https:&#x2F;&#x2F;www.jntrnr.com&#x2F;processed_images&#x2F;53af5229a2f8852200.png" />

    <title>
      
        
          Porting a C# NES emulator to Rust
        
      
    </title>

    
    
      <link rel="stylesheet" href="https://www.jntrnr.com/main.css">
    
    
  
    <link rel="prerender" href="https:&#x2F;&#x2F;www.jntrnr.com&#x2F;steam-machines&#x2F;">
  

  
    <link rel="prerender" href="https:&#x2F;&#x2F;www.jntrnr.com&#x2F;building-a-simple-jit-in-rust&#x2F;">
  

  
    <link rel="prerender"  href="https:&#x2F;&#x2F;www.jntrnr.com&#x2F;tags&#x2F;rust&#x2F;">
  
    <link rel="prerender"  href="https:&#x2F;&#x2F;www.jntrnr.com&#x2F;tags&#x2F;emulation&#x2F;">
  

  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "NewsArticle",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://google.com/article"
      },
      "headline": "Porting a C# NES emulator to Rust",
      "image": [],
      "datePublished": "2015-11-20T00:00:00+00:00",
      "dateModified": "2015-11-20T00:00:00+00:00",
      "author": {
        "@type": "Person",
        "name": "JT"
      },
       "publisher": {
        "@type": "Organization",
        "name": "JT",
        "logo": {
          "@type": "ImageObject",
          "url": "https://www.jntrnr.com/icon.png"
        }
        
      }
      
    }
  </script>

  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      "itemListElement": [
        

        
        {
          
          "@type": "ListItem",
          "position": 1,
          "name": "",
          "item": "https://www.jntrnr.com/"
        },
        
        {
          "@type": "ListItem",
          "position": 2,
          "name": "Porting a C# NES emulator to Rust",
          "item": "https://www.jntrnr.com/porting-csharp-nes-emu-to-rust/"
        }
      ]
    }
  </script>

  </head>
  <body>
    
      <header>
        <a class="profile-icon" href="/">
          <img src="https:&#x2F;&#x2F;www.jntrnr.com&#x2F;processed_images&#x2F;53af5229a2f8852200.png" alt="profile picture">
        </a>
        <nav>
          
            <a href="&#x2F;">Home</a>
          
            <a href="&#x2F;tags">Tags</a>
          
            <a href="https:&#x2F;&#x2F;www.twitter.com&#x2F;jntrnr">Twitter</a>
          
            <a href="&#x2F;atom.xml">Atom&#x2F;RSS</a>
          
            <a href="&#x2F;poems&#x2F;waitingtogrow">Poems</a>
          
        </nav>
      </header>
    
    <main>
    
  <div class="post-title">
    <h1>Porting a C# NES emulator to Rust</h1>
    <small>
      November 20, 2015
      
        - 
        <span class="tags">
          
            <a href="https:&#x2F;&#x2F;www.jntrnr.com&#x2F;tags&#x2F;rust&#x2F;">rust</a>
          
            <a href="https:&#x2F;&#x2F;www.jntrnr.com&#x2F;tags&#x2F;emulation&#x2F;">emulation</a>
          
        </span>
      
    </small>
  </div>

  <div>
    <p>Many years ago, I created a <a href="http://jturner.tapetrade.net/sharpnes/index.html">simple NES emulator in C#</a> using SDL and Mono.  For fun, I wanted to see what it would be like to port that emulator to Rust.  A couple weeks later, after poking on it on and off between packing for a move, I was able to <a href="https://github.com/jntrnr/rustynes">get it working</a>.</p>
<p><img src="http://www.jonathanturner.org/images/smb1.png" alt="Image of Super Mario Bros 1 on emulator" /></p>
<h1 id="what-i-did">What I did</h1>
<h2 id="loading-a-binary-file">Loading a binary file</h2>
<p>Loading the types of files commonly used in emulators requires us to work with binary files.  To do so, we need a way of loading the raw data both as just plain bytes and also as numbers.  Rust, by default, comes with a <a href="https://doc.rust-lang.org/std/fs/struct.File.html">fairly slim API</a> for dealing with binary data.  No matter, Rust is also very flexible and allows you to build on additional parts to the API to suit your needs.</p>
<p>I started there, and built out a few functions that would let me read in the numbers from the file both using big-endian and little-endian.</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">pub trait </span><span style="color:#c0c5ce;">BitReader {
    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">read_u32_be</span><span style="color:#c0c5ce;">(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">) -&gt; Result&lt;</span><span style="color:#b48ead;">u32</span><span style="color:#c0c5ce;">, io::Error&gt;;
    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">read_u32_le</span><span style="color:#c0c5ce;">(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">) -&gt; Result&lt;</span><span style="color:#b48ead;">u32</span><span style="color:#c0c5ce;">, io::Error&gt;;
}
</span><span style="color:#b48ead;">impl </span><span style="color:#c0c5ce;">BitReader </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">File {
    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">read_u32_be</span><span style="color:#c0c5ce;">(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">) -&gt; Result&lt;</span><span style="color:#b48ead;">u32</span><span style="color:#c0c5ce;">, io::Error&gt; {
        </span><span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> buffer = [</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">; </span><span style="color:#d08770;">4</span><span style="color:#c0c5ce;">];
    
        try!(</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.</span><span style="color:#96b5b4;">read</span><span style="color:#c0c5ce;">(&amp;</span><span style="color:#b48ead;">mut</span><span style="color:#c0c5ce;"> buffer));
        
        Ok(buffer[</span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">] as </span><span style="color:#b48ead;">u32 </span><span style="color:#c0c5ce;">+ ((buffer[</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">] as </span><span style="color:#b48ead;">u32</span><span style="color:#c0c5ce;">) &lt;&lt; </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">) +
            ((buffer[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">] as </span><span style="color:#b48ead;">u32</span><span style="color:#c0c5ce;">) &lt;&lt; </span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">) + ((buffer[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">] as </span><span style="color:#b48ead;">u32</span><span style="color:#c0c5ce;">) &lt;&lt; </span><span style="color:#d08770;">24</span><span style="color:#c0c5ce;">))    
    }
    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">read_u32_le</span><span style="color:#c0c5ce;">(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">) -&gt; Result&lt;</span><span style="color:#b48ead;">u32</span><span style="color:#c0c5ce;">, io::Error&gt; {
        </span><span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> buffer = [</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">; </span><span style="color:#d08770;">4</span><span style="color:#c0c5ce;">];
    
        try!(</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.</span><span style="color:#96b5b4;">read</span><span style="color:#c0c5ce;">(&amp;</span><span style="color:#b48ead;">mut</span><span style="color:#c0c5ce;"> buffer));
        
        Ok(buffer[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">] as </span><span style="color:#b48ead;">u32 </span><span style="color:#c0c5ce;">+ ((buffer[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">] as </span><span style="color:#b48ead;">u32</span><span style="color:#c0c5ce;">) &lt;&lt; </span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">) +
            ((buffer[</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">] as </span><span style="color:#b48ead;">u32</span><span style="color:#c0c5ce;">) &lt;&lt; </span><span style="color:#d08770;">16</span><span style="color:#c0c5ce;">) + ((buffer[</span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">] as </span><span style="color:#b48ead;">u32</span><span style="color:#c0c5ce;">) &lt;&lt; </span><span style="color:#d08770;">24</span><span style="color:#c0c5ce;">))    
    }
}
</span></code></pre>
<p>Once I had the trait, I could import it where I wanted to use these extra read capabilities on File.</p>
<p>With these extra methods in place, I could plow through the binary file loading with a mix of the File read functionality and the BitReader trait.</p>
<p>I did notice I used the odd concoction <code>buffer.iter().cloned().collect()</code> to convert from an array to a Vec of the same contained type:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">_ in </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">..(num_prg_pages*</span><span style="color:#d08770;">4</span><span style="color:#c0c5ce;">) {
    </span><span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> buffer = [</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">; </span><span style="color:#d08770;">4096</span><span style="color:#c0c5ce;">];
    try!(f.</span><span style="color:#96b5b4;">read</span><span style="color:#c0c5ce;">(&amp;</span><span style="color:#b48ead;">mut</span><span style="color:#c0c5ce;"> buffer));
    prg_rom.</span><span style="color:#96b5b4;">push</span><span style="color:#c0c5ce;">(buffer.</span><span style="color:#96b5b4;">iter</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">cloned</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">collect</span><span style="color:#c0c5ce;">());
}
</span></code></pre>
<p>There may be a more Rust-native way of doing it.  Personally, I think it'd be nice to be able to read directly into a Vec, so you could elide that step.</p>
<h2 id="side-by-side-porting">Side-by-side porting</h2>
<p>One of the first things I did after I had file loading in place was to start porting over the CPU emulation.  Because I wanted the code to be fairy clean, I opted to not do a literal port.  Instead, I opened two separate editor windows: one for the original C# source, and one for the new Rust source.  Tedious, but I hoped that a port focused on what would fit better with Rust would be less error-prone.</p>
<p>There's another reason not to do copy/pasting of code when porting: too many little things needed to be changed to the Rust style. For example, Rust-friendly names often differ from the C# equivalent (eg the ReadChrRom method would need to be read_chr_rom to match Rust naming conventions).  Like-wise, little things that help readability in Rust, like the &quot;no parens around if guards&quot; means that copy/pasted code would need to be touched up.  All told, a minor frustration, but it gave ample time to make the code look a bit cleaner in the transfer so likely a net win.</p>
<p>Feeling more comfortable with Rust's use of expressions, I could write code in a more dense way.  For example, here is some code from the ROR or Rotate Right opcode in C#:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">if ((valueholder &amp; 0x1) == 0x1)
	bitholder = 1;
else
	bitholder = 0;
	
valueholder = (byte)(valueholder &gt;&gt; 1);

if (carry_flag == 1)
	valueholder = (byte)(valueholder | 0x80);

carry_flag = bitholder;

if ((valueholder &amp; 0xff) == 0x0)
	zero_flag = 1;
else
	zero_flag = 0;
	
if ((valueholder &amp; 0x80) == 0x80)
	sign_flag = 1;
else
	sign_flag = 0;
</span></code></pre>
<p>and here's what it became in Rust:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> bit = (value &amp; </span><span style="color:#d08770;">0x1</span><span style="color:#c0c5ce;">) == </span><span style="color:#d08770;">0x1</span><span style="color:#c0c5ce;">;
value = (value &gt;&gt; </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">) &amp; </span><span style="color:#d08770;">0x7f</span><span style="color:#c0c5ce;">;
value += </span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.carry {</span><span style="color:#d08770;">0x80</span><span style="color:#c0c5ce;">} </span><span style="color:#b48ead;">else </span><span style="color:#c0c5ce;">{</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">};
</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.carry = bit;
</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.zero = value == </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.sign = (value &amp; </span><span style="color:#d08770;">0x80</span><span style="color:#c0c5ce;">) == </span><span style="color:#d08770;">0x80</span><span style="color:#c0c5ce;">;  
</span></code></pre>
<p>Some of these changes could have been done in the original C#, but I didn't notice them at the time.  Still, I think the result Rust is still pretty readable, even though it's more compact.</p>
<p>While we're talking about bit rotation, one of the annoyances I experienced working on bit manipulation code is that Rust is more vigilant about overflow checking.  In hindsight, this is actually a good thing, but coming from languages like C# and JavaScript that are less vigilant, it was a bit of a headache to adjust to.  I ended up doing some of my own bit masks so I didn't have to worry about it, but I noticed that they've added a number of <a href="https://github.com/brson/rust/blob/relnotes/RELEASES.md#libraries">&quot;wrapping&quot; operations in Rust 1.4</a> that allow you to work around the overflow checks.</p>
<h2 id="hitting-the-first-ownership-error">Hitting the first ownership error</h2>
<p>A few days into the port, I hit my first ownership error.  Here's a quick rundown of the NES, so you can see why that might be so:</p>
<ul>
<li>CPU: The CPU :)</li>
<li>PPU: The NES's graphics unit</li>
<li>MMU: Not technically not called the MMU, but let's call it an MMU for our purposes</li>
<li>Cart: The program to run</li>
</ul>
<p>Now that we have the parts, here's how they talk to each other:</p>
<ul>
<li>CPU asks the MMU for an instruction, and the CPU may also write back to memory</li>
<li>PPU reads memory from the Cart, and can also transfer memory from MMU to graphics memory</li>
<li>MMU needs to read information from the Cart and can also read and write from the PPU</li>
</ul>
<p>All the subsystems, in essence, need to be able to talk to each other at some level.  Which is exactly how I set up the C# project.  Singleton objects with references to each other.  When I ported over to TypeScript a few years ago, similar idea.</p>
<p>But in Rust, ownership needs to be clear.  If you call a method, you can't also pass something you own to that method, like so:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">foo.x.</span><span style="color:#96b5b4;">y</span><span style="color:#c0c5ce;">(foo.x.z)
</span></code></pre>
<p>The net result is that I went back to the drawing board and thought long and hard about what was <em>actually</em> necessary for each component.  After a couple of refactorings, I think I landed on a solution that's both cleaner and clearer.  Every object has one owner, and I don't do any ref cells or ref counting.</p>
<h2 id="deriving-debug">Deriving debug</h2>
<p>There are a few tricks that I loved in Haskell that I wished other languages would pick up.  One of them is the ability to automatically be able to print out objects for you.</p>
<p>In Rust, you can do this using the 'derive' command:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">#[</span><span style="color:#bf616a;">derive</span><span style="color:#c0c5ce;">(Debug)]
</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">Foo {
  </span><span style="color:#bf616a;">x</span><span style="color:#c0c5ce;">: </span><span style="color:#b48ead;">u32
</span><span style="color:#c0c5ce;">}
</span><span style="color:#65737e;">//...

</span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> foo = Foo { x: </span><span style="color:#d08770;">10 </span><span style="color:#c0c5ce;">}
println!(&quot;</span><span style="color:#d08770;">{:?}</span><span style="color:#c0c5ce;">&quot;, foo);
</span></code></pre>
<p>By deriving Debug, you have the ability to output a debug format of that structure, which is output using {:?}.</p>
<p>This is very handy to help bootstrap a project, when you quickly want to look at the contents of what is working so far.  After a while, I found I ended up removing these helpers and putting in my own, customized implementations.</p>
<h2 id="sdl">SDL</h2>
<p>Using SDL was dead simple.  I used the <a href="https://github.com/AngryLawyer/rust-sdl2">SDL2 Rust bindings</a>.  After a few tries to follow the directions to install SDL2 carefully, I had it working in both Windows and OS X.  After it's installed, the bindings &quot;just work&quot;.</p>
<p>I'd never used SDL2 before, but after looking through the <a href="https://github.com/AngryLawyer/rust-sdl2/tree/master/examples">examples directory</a>, especially the texture sample, I was good to go.</p>
<h1 id="what-i-didn-t-do">What I didn't do</h1>
<h2 id="chase-crashing-bugs">Chase crashing bugs</h2>
<p>After wrestling a few ownership errors, I largely spent my time on correctness.  I ended up having a few hard-to-find issues where I flipped the boolean logic on a check or discovering I forgot to implement a piece of the machine that was required.  After many hours pouring over the code side by side, or looking at the output log, I finally managed to get the outputs similar.</p>
<p>Just as in the C# and JavaScript versions of the emulator, I didn't worry about any crashes.  A few times I had an arithmetic overflow or error accessing a vector out of bounds, but those were easy to fix.</p>
<h2 id="optimize">Optimize</h2>
<p>After I got the emulator working, I let it rip.  The result was something unplayably fast.  Not bad for a first try.</p>
<p>In hindsight, this isn't too surprising.  The CPU gets to work directly with the MMU.  Ditto with the MMU and the PPU.  The systems can call functions in each other without any abstraction, VM, or GC.  By default, the core structs sit on the stack.</p>
<p>Using Rust had nudged me into doing what would have made sense for a decent C-based approach, without the risks.  Of course, it's not like Rust prevents you from adding in a hefty abstraction layer, but the defaults seem to push you in the right direction. </p>
<h2 id="unit-test">Unit test</h2>
<p>For this to feel like a real Rust project, though, it needs some tests.  I asked <a href="https://twitter.com/pcwalton">Patrick Walton</a>, the author of probably the <a href="https://github.com/pcwalton/sprocketnes">first NES emulator for Rust</a>, about testing emulators with Rust unit tests, but he didn't use them for his project either.</p>
<p>Still, I suspect there's a way of creating fairly testable, and still performant, parts of the emulator.  For example, opcodes could each have their own unit test if there was a way, possibly with traits, to decouple them from working so closely with the MMU.</p>
<h2 id="add-audio-support">Add audio support</h2>
<p>In Patrick's <a href="https://air.mozilla.org/sprocketnes-practical-systems-programming-in-rust/">video about his emulator</a>, he mentions that he took it on to show that Rust can do real-time processing.  For an emulator, that means that the audio is emulated properly and sounds correct.  I haven't added any audio support, but it would be a fun project at some point.</p>
<h2 id="precisely-emulate-the-machine">Precisely emulate the machine</h2>
<p>The never-ending rabbit hole for any emulation project is to see just how precisely you can emulate the hardware.  There's plenty of work here.</p>
<h1 id="what-i-ve-learned">What I've learned</h1>
<p>I'm getting a little more comfortable with Rust.  Thinking through an ownership refactoring can still take a while, but it's starting to feel like the hurdle you take on so that you can worry less about safety and performance.  I still have a ways to go before it becomes second nature.</p>
<p>Cargo shines again, and the SDL bindings were easy to put in place and worked as expected.  No complaints there.</p>
<p>Feels like I'm still scratching the surface.  There are likely some slick spots to use traits and macros to cut down on the redundancy and coupling, repectively.  But I'm happy with the progress.</p>

  </div>

  <hr class="footer-rule" />

  
    <div class="footer-about">
      <p>A simple dev-blog theme created by Bennett. You can follow him on <a href="https://github.com/bennetthardwick">Github</a> (if you like).</p>

    </div>
  

  <div class="related-container">

    
      <div class="link">
        Previous <br />
        <a href="https:&#x2F;&#x2F;www.jntrnr.com&#x2F;steam-machines&#x2F;">Steam Machines enter the market</a>
      </div>
    

    
      <div class="link">
        Next <br />
        <a href="https:&#x2F;&#x2F;www.jntrnr.com&#x2F;building-a-simple-jit-in-rust&#x2F;">Building a simple JIT in Rust</a>
      </div>
    

  </div>


    </main>
  </body>
</html>
